#define PROBLEM "https://yukicoder.me/problems/no/1031"
#include "../utils/macros.hpp"
#include "../data_structure/sparse_table.hpp"
#include "../data_structure/segment_tree.hpp"
#include "../monoids/max.hpp"
#include <climits>
#include <cmath>
#include <deque>
#include <functional>
#include <iostream>
#include <optional>
#include <tuple>
#include <utility>
#include <vector>
using namespace std;
#include "../old/rollback-square-decomposition.inc.cpp"

template <class T>
struct rollbackable_deque {
    deque<T> data;
    vector<pair<char, optional<T> > > history;
    rollbackable_deque() = default;
    bool empty() const { return data.empty(); }
    size_t size() const { return data.size(); }
    T operator [] (size_t i) const { return data[i]; }
    const T & front() const { return data.front(); }
    const T & back() const { return data.back(); }
    void push_front(T value) {
        history.emplace_back('f', optional<T>());
        data.push_front(value);
    }
    void pop_front() {
        history.emplace_back('F', data.front());
        data.pop_front();
    }
    void push_back(T value) {
        history.emplace_back('b', optional<T>());
        data.push_back(value);
    }
    void pop_back() {
        history.emplace_back('B', data.back());
        data.pop_back();
    }
    void snapshot() {
        history.emplace_back('$', optional<T>());
    }
    void rollback() {
        while (history.back().first != '$') {
            char op = history.back().first;
            optional<T> value = history.back().second;
            history.pop_back();
            if (op == 'f') {
                data.pop_front();
            } else if (op == 'F') {
                data.push_front(*value);
            } else if (op == 'b') {
                data.pop_back();
            } else if (op == 'B') {
                data.push_back(*value);
            }
        }
        history.pop_back();
    }
};

struct rollback_mo_inc {
    const vector<int> & p;
    int64_t & ans;
    int l, r;
    vector<pair<int, int> > history;
    rollbackable_deque<int> deq;
    rollback_mo_inc(const vector<int> & p_, int64_t & ans_) : p(p_), ans(ans_) {
        reset(0);
    }
    void reset(int l_) {
        l = l_;
        r = l_;
        history.clear();
        deq = rollbackable_deque<int>();
    }
    void extend_left(int nl, int r) {
        for (; nl < l; -- l) {
            if (deq.empty() or p[l - 1] < deq.front()) {
                deq.push_front(p[l - 1]);
            }
        }
    }
    void extend_right(int l, int nr) {
        for (; r < nr; ++ r) {
            while (not deq.empty() and p[r] < deq.back()) {
                deq.pop_back();
            }
            deq.push_back(p[r]);
        }
    }
    void snapshot() {
        deq.snapshot();
        history.emplace_back(l, r);
    }
    void rollback() {
        deq.rollback();
        tie(l, r) = history.back();
        history.pop_back();
    }
    void query() {
        ans += deq.size();
    }
};

int64_t solve1(int n, const vector<int> & p) {
    vector<pair<int, int> > query_inc;
    vector<int> lookup(n);
    REP (i, n) {
        lookup[p[i]] = i;
    }
    sparse_table<max_monoid<int> > table(ALL(p));
    function<void (int, int)> go = [&](int l, int r) {
        if (r - l < 2) return;
        int m = lookup[table.range_get(l, r)];
        query_inc.emplace_back(l, m);
        go(l, m);
        go(m + 1, r);
    };
    go(0, n);

    int64_t ans = 0;
    rollback_mo_inc interface_inc(p, ans);
    rollback_square_decomposition(n, query_inc, interface_inc, [&](int l, int r) {
        int last = INT_MAX;
        REP3R (i, l, r) {
            if (p[i] < last) {
                last = p[i];
                ++ ans;
            }
        }
    });
    return ans;
}

int64_t solve(int n, vector<int> p) {
    int64_t ans = solve1(n, p);
    reverse(ALL(p));
    return ans + solve1(n, p);
}

// generated by online-judge-template-generator v4.1.0 (https://github.com/kmyk/online-judge-template-generator)
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    constexpr char endl = '\n';
    int N;
    cin >> N;
    vector<int> p(N);
    REP (i, N) {
        cin >> p[i];
        -- p[i];
    }
    auto ans = solve(N, p);
    cout << ans << endl;
    return 0;
}
